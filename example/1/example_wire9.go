// MACHINE GENERATED BY 'go generate' COMMAND
// TO EDIT A TYPE OR METHOD, COPY IT TO ANOTHER FILE IN THE PACKAGE
package main

import (
	"encoding/binary"
	"bytes"
	"io"
	"fmt"
)

func writestring(w io.Writer, s string, must int) (err error) {
	data := []byte(s)
	switch l := len(data); {
	case l > must:
		_, err = w.Write(data[:must])
	case l < must:
		_, err = w.Write(data[:l])
		if err != nil {
			return err
		}
		underflow := must - l
		_, err = w.Write(bytes.Repeat([]byte{0x00}, underflow))
	default:
		_, err = w.Write(data[:l])
	}
	return err
}

func ioErr(name, kind string, ac, ex int) error {
	return fmt.Errorf("%s: short %s: %d/%d", name, kind, ac, ex)
}

type Pstr struct {
	n	byte
	data	[]byte
}

type Bstr struct {
	n	uint16
	data	[]byte
}

type Mestr struct {
	n	uint32
	data	[]byte
}

type u64s struct {
	n	uint64
	data	[]byte
}

type i64s struct {
	n	int64
	data	[]byte
}

type BBEStr struct {
	n	int64
	data	[]byte
}

type ApeStr struct {
	n	uint16
	data	[]Pstr
}

func (z *Pstr) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *Pstr) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *Bstr) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *Bstr) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *Mestr) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *Mestr) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *u64s) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *u64s) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *i64s) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *i64s) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *BBEStr) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]byte, int(z.n))

	if n, err := r.Read(z.data); err != nil || n != int(z.n) {
		return err
	}

	return nil
}

func (z *BBEStr) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	{
		x := int(z.n)
		if n, err := w.Write(z.data[:x]); err != nil || n != x {
			return err
		}
	}
	return nil
}

func (z *ApeStr) ReadBinary(r io.Reader) (err error) {
	defer func() { recover() }()
	if z == nil {
		return fmt.Errorf("ReadBinary: z nil")
	}

	if err := binary.Read(r, binary.LittleEndian, &z.n); err != nil {
		return err
	}

	z.data = make([]Pstr, int(z.n))
	for i := 0; i < int(z.n); i++ {

		if err := z.data[i].ReadBinary(r); err != nil {
			return err
		}
	}

	return nil
}

func (z *ApeStr) WriteBinary(w io.Writer) (err error) {
	defer func() { recover() }()

	if err := binary.Write(w, binary.LittleEndian, z.n); err != nil {
		return err
	}

	z.data = make([]Pstr, int(z.n))
	for i := 0; i < int(z.n); i++ {
		if err := z.data[i].WriteBinary(w); err != nil {
			return err
		}
	}

	return nil
}
