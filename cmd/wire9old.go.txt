package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"

	"golang.org/x/tools/go/loader"

	"github.com/as/wire9"
)

var (
	nofmt    = flag.Bool("d", false, "debug: no gofmt")
	verbose  = flag.Bool("v", false, "debug: be verbose")
	filename = flag.String("f", "", "output file name (default stdout")
	z        = flag.Bool("z", false, "z demo mode")
)

func usage() {
	fmt.Fprintf(os.Stderr, "usage: wire9 [-f outfile] [path ...]\n")
	os.Exit(0)
}

func init() {
	flag.Parse()
}

// Type checking using the loader package
func loadfiles() {
	if len(flag.Args()) < 1 {
		usage()
	}
	//file := flag.Args()[0]
	var conf loader.Config
	conf.CreateFromFilenames("main", "/usr/as/wire9/old/str.go")
	prog, err := conf.Load()
	if err != nil {
		log.Fatal(err)
	}
	pkg := prog.Package("main")
	if pkg == nil {
		log.Fatal("nil pkg")
	}
	fmt.Println(pkg)
	pkg2 := pkg.Pkg
	fmt.Printf("%#v\n", pkg)
	fmt.Printf("%#v\n", pkg2)
	os.Exit(0)
}

// Type checking using the parser and the checker seperately
func loadfiles2() {
	FileTypeInfo("/usr/as/wire9/old/str.go")
}

// FileTypeInfo returns a *types.Info with a non-nil
// Uses, Defs, and Types map.
func FileTypeInfo(filename string) *types.Info {
	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filename, nil, 0)
	if err != nil {
		log.Fatal(err)
	}
	conf := types.Config{Importer: importer.Default()}
	info := &types.Info{
		Types:      make(map[ast.Expr]types.TypeAndValue),
		Defs:       make(map[*ast.Ident]types.Object),
		Uses:       make(map[*ast.Ident]types.Object),
		Implicits:  make(map[ast.Node]types.Object),
		Selections: make(map[*ast.SelectorExpr]*types.Selection),
		Scopes:     make(map[ast.Node]*types.Scope),
	}
	_, err = conf.Check("main", fset, []*ast.File{f}, info)
	if err != nil {
		log.Fatal(err)
	}

	/*for k, v := range info.Types{fmt.Printf("Types: %#v: %#v\n", k, v)}
	for k, v := range info.Defs{fmt.Printf("Defs: %#v: %#v\n", k, v)}
	for k, v := range info.Uses{fmt.Printf("Uses: %#v: %#v\n", k, v)}
	for k, v := range info.Implicits{fmt.Printf("Implicits: %#v: %#v\n", k, v)}
	for k, v := range info.Selections{fmt.Printf("Selections: %#v: %#v\n", k, v)}
	*/
	for k, _ := range info.Scopes {
		if t, ok := k.(*ast.File); ok {
			ast.Print(nil, t)
		}
		//fmt.Printf("Scopes: %#v: %#v\n", k, v)
	}

	os.Exit(0)
	return info
}


func main() {
	a := flag.Args()
	if len(a) == 0 {
		log.Fatal("usage: wire9 [package | files ...]")
	}
	if isdir(a[0]) {
		dopackage(a[0])
	} else {
		dofiles(a...)
	}
}

func isdir(s string) bool {
	fi, err := os.Stat(s)
	if err != nil {
		log.Fatal(err)
	}
	return fi.IsDir()
}

func dopackage(dir string){
	pkg, err := wire9.OpenPackage(dir)
	no(err)
	
	wire, err := wire9.FromPackage(pkg, true)
	no(err)
	
	fmt.Printf("// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT\n%s",wire.Data)
}


func no(err error){
	if err != nil {
		log.Fatalf("wire9: %s\n", err)
	}
}

func debugf(f string, i ...interface{}) (n int, err error) {
	if !*verbose {
		return
	}
	return fmt.Fprintf(os.Stderr, "wire9: "+f, i...)
}

func dofiles(list ...string) {
	var buf bytes.Buffer
	fmt.Fprint(&buf, FIXTHIS)
	src, err := wire9.ParseFiles(list)
	if err != nil {
		log.Fatal("parse:", err)
	}
	if *verbose {
	}

	if err := src.Generate(&buf); err != nil {
		log.Fatal("gen:", err)
	}
	data := wire9.Clean(buf.Bytes())
	if !*nofmt {
		data, err = format.Source(data)
		if err != nil {
			log.Fatal("gofmt:", err)
		}
	}

	if *filename == "" {
		_, err = os.Stdout.Write(data)
	} else {
		err = ioutil.WriteFile(*filename, data, 0644)
	}
	if err != nil {
		log.Fatal(err)
	}
}

type BlockWalker struct {
	parent ast.Node
}

const FIXTHIS = `
// MACHINE GENERATED BY 'go generate' COMMAND; DO NOT EDIT
package main

import (
	"encoding/binary"
	"bytes"
	"io"
	"fmt"
)
`
